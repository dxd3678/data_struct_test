// Autogenerated with StateSmith 0.9.4-alpha-fix-1.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "LaserTagMenu1Sm.h"
#include "App.h"
#include "Display.h"
#include "PortApi.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(LaserTagMenu1Sm* sm, LaserTagMenu1Sm_Func desired_state_exit_handler);

static void ROOT_enter(LaserTagMenu1Sm* sm);

static void ROOT_exit(LaserTagMenu1Sm* sm);

static void HOME_enter(LaserTagMenu1Sm* sm);

static void HOME_exit(LaserTagMenu1Sm* sm);

static void HOME_ok_press(LaserTagMenu1Sm* sm);

static void HOME_InitialState_transition(LaserTagMenu1Sm* sm);

static void HOME1_enter(LaserTagMenu1Sm* sm);

static void HOME1_exit(LaserTagMenu1Sm* sm);

static void HOME1_down_press(LaserTagMenu1Sm* sm);

static void HOME1_up_press(LaserTagMenu1Sm* sm);

static void HOME2_enter(LaserTagMenu1Sm* sm);

static void HOME2_exit(LaserTagMenu1Sm* sm);

static void HOME2_down_press(LaserTagMenu1Sm* sm);

static void HOME2_up_press(LaserTagMenu1Sm* sm);

static void HOME3_enter(LaserTagMenu1Sm* sm);

static void HOME3_exit(LaserTagMenu1Sm* sm);

static void HOME3_down_press(LaserTagMenu1Sm* sm);

static void HOME3_up_press(LaserTagMenu1Sm* sm);

static void MENUS_GROUP_enter(LaserTagMenu1Sm* sm);

static void MENUS_GROUP_exit(LaserTagMenu1Sm* sm);

static void MENUS_GROUP_back_held(LaserTagMenu1Sm* sm);

static void MENUS_GROUP_back_press(LaserTagMenu1Sm* sm);

static void CLASS_SAVED_enter(LaserTagMenu1Sm* sm);

static void CLASS_SAVED_exit(LaserTagMenu1Sm* sm);

static void CLASS_SAVED_do(LaserTagMenu1Sm* sm);

static void MAIN_MENU_enter(LaserTagMenu1Sm* sm);

static void MAIN_MENU_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_OPTION_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_OPTION_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_OPTION_ok_press(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_OPTION_up_press(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_OPTION_enter(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_OPTION_exit(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_OPTION_down_press(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_OPTION_ok_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_OPTION_enter(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_OPTION_exit(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_OPTION_down_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_OPTION_ok_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_OPTION_up_press(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_back_press(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_1_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_1_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_1_do(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_2_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_2_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_2_do(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_3_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_3_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_3_do(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_4_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_4_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_4_do(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_5_enter(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_5_exit(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_5_back_press(LaserTagMenu1Sm* sm);

static void MM_BACK_PRESS_EATER_5_do(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_enter(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_exit(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_back_press(LaserTagMenu1Sm* sm);

static void MM_SELECT_CLASS_ok_press(LaserTagMenu1Sm* sm);

static void MM_SC_ENGINEER_enter(LaserTagMenu1Sm* sm);

static void MM_SC_ENGINEER_exit(LaserTagMenu1Sm* sm);

static void MM_SC_ENGINEER_down_press(LaserTagMenu1Sm* sm);

static void MM_SC_MID_enter(LaserTagMenu1Sm* sm);

static void MM_SC_MID_exit(LaserTagMenu1Sm* sm);

static void MM_SC_MID_down_held(LaserTagMenu1Sm* sm);

static void MM_SC_MID_up_held(LaserTagMenu1Sm* sm);

static void MM_SC_ARCHER_enter(LaserTagMenu1Sm* sm);

static void MM_SC_ARCHER_exit(LaserTagMenu1Sm* sm);

static void MM_SC_ARCHER_down_press(LaserTagMenu1Sm* sm);

static void MM_SC_ARCHER_up_press(LaserTagMenu1Sm* sm);

static void MM_SC_HEAVY_enter(LaserTagMenu1Sm* sm);

static void MM_SC_HEAVY_exit(LaserTagMenu1Sm* sm);

static void MM_SC_HEAVY_down_press(LaserTagMenu1Sm* sm);

static void MM_SC_HEAVY_up_press(LaserTagMenu1Sm* sm);

static void MM_SC_WIZARD_enter(LaserTagMenu1Sm* sm);

static void MM_SC_WIZARD_exit(LaserTagMenu1Sm* sm);

static void MM_SC_WIZARD_down_press(LaserTagMenu1Sm* sm);

static void MM_SC_WIZARD_up_press(LaserTagMenu1Sm* sm);

static void MM_SC_SPY_enter(LaserTagMenu1Sm* sm);

static void MM_SC_SPY_exit(LaserTagMenu1Sm* sm);

static void MM_SC_SPY_up_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_enter(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_exit(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_back_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_1_enter(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_1_exit(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_1_do(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_1_down_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_2_enter(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_2_exit(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_2_do(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_2_down_press(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_3_enter(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_3_exit(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_3_do(LaserTagMenu1Sm* sm);

static void MM_SHOW_INFO_3_down_press(LaserTagMenu1Sm* sm);

static void WELCOME_SCREEN_enter(LaserTagMenu1Sm* sm);

static void WELCOME_SCREEN_exit(LaserTagMenu1Sm* sm);

static void WELCOME_SCREEN_do(LaserTagMenu1Sm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void LaserTagMenu1Sm_ctor(LaserTagMenu1Sm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void LaserTagMenu1Sm_start(LaserTagMenu1Sm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.InitialState`.
        // ROOT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.InitialState behavior
        // uml: TransitionTo(WELCOME_SCREEN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WELCOME_SCREEN`.
            WELCOME_SCREEN_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LaserTagMenu1Sm_StateId_WELCOME_SCREEN;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void LaserTagMenu1Sm_dispatch_event(LaserTagMenu1Sm* sm, LaserTagMenu1Sm_EventId event_id)
{
    LaserTagMenu1Sm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(LaserTagMenu1Sm* sm, LaserTagMenu1Sm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(LaserTagMenu1Sm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

static void HOME_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = HOME_ok_press;
}

static void HOME_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME_ok_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // HOME behavior
    // uml: OK_PRESS TransitionTo(MAIN_MENU)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU`.
        MENUS_GROUP_enter(sm);
        MAIN_MENU_enter(sm);
        
        // MAIN_MENU.InitialState behavior
        // uml: TransitionTo(MM_SELECT_CLASS_OPTION)
        {
            // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MM_SELECT_CLASS_OPTION`.
            MM_SELECT_CLASS_OPTION_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for MAIN_MENU.InitialState
    } // end of behavior for HOME
}

static void HOME_InitialState_transition(LaserTagMenu1Sm* sm)
{
    // HOME.InitialState behavior
    // uml: TransitionTo(HOME1)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME1`.
        HOME1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME1;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for HOME.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME1
////////////////////////////////////////////////////////////////////////////////

static void HOME1_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME1_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME1_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME1_up_press;
    
    // HOME1 behavior
    // uml: enter / { show_home_screen_1(); }
    {
        // Step 1: execute action `show_home_screen_1();`
        Display_show_home_screen_1();
    } // end of behavior for HOME1
}

static void HOME1_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME1_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // HOME1 behavior
    // uml: DOWN_PRESS TransitionTo(HOME2)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition).
        HOME1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME2`.
        HOME2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HOME1
}

static void HOME1_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // HOME1 behavior
    // uml: UP_PRESS TransitionTo(HOME3)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition).
        HOME1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME3`.
        HOME3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HOME1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME2
////////////////////////////////////////////////////////////////////////////////

static void HOME2_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME2_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME2_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME2_up_press;
    
    // HOME2 behavior
    // uml: enter / { show_home_screen_2(); }
    {
        // Step 1: execute action `show_home_screen_2();`
        Display_show_home_screen_2();
    } // end of behavior for HOME2
}

static void HOME2_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME2_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // HOME2 behavior
    // uml: DOWN_PRESS TransitionTo(HOME3)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition).
        HOME2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME3`.
        HOME3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HOME2
}

static void HOME2_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // HOME2 behavior
    // uml: UP_PRESS TransitionTo(HOME1)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition).
        HOME2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME1`.
        HOME1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HOME2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME3
////////////////////////////////////////////////////////////////////////////////

static void HOME3_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HOME3_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME3_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME3_up_press;
    
    // HOME3 behavior
    // uml: enter / { show_home_screen_3(); }
    {
        // Step 1: execute action `show_home_screen_3();`
        Display_show_home_screen_3();
    } // end of behavior for HOME3
}

static void HOME3_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = HOME_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME3_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // HOME3 behavior
    // uml: DOWN_PRESS TransitionTo(HOME1)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition).
        HOME3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME1`.
        HOME1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HOME3
}

static void HOME3_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // HOME3 behavior
    // uml: UP_PRESS TransitionTo(HOME2)
    {
        // Step 1: Exit states until we reach `HOME` state (Least Common Ancestor for transition).
        HOME3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME2`.
        HOME2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_HOME2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HOME3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENUS_GROUP
////////////////////////////////////////////////////////////////////////////////

static void MENUS_GROUP_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MENUS_GROUP_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_HELD] = MENUS_GROUP_back_held;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;
}

static void MENUS_GROUP_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_HELD] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MENUS_GROUP_back_held(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `back_held` event.
    
    // MENUS_GROUP behavior
    // uml: BACK_HELD TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        HOME_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MENUS_GROUP
}

static void MENUS_GROUP_back_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `back_press` event.
    
    // MENUS_GROUP behavior
    // uml: BACK_PRESS TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        HOME_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for MENUS_GROUP
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CLASS_SAVED
////////////////////////////////////////////////////////////////////////////////

static void CLASS_SAVED_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CLASS_SAVED_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = CLASS_SAVED_do;
    
    // CLASS_SAVED behavior
    // uml: enter / { Display_class_saved(); }
    {
        // Step 1: execute action `Display_class_saved();`
        Display_class_saved();
    } // end of behavior for CLASS_SAVED
    
    // CLASS_SAVED behavior
    // uml: enter / { reset_timer1(); }
    {
        // Step 1: execute action `reset_timer1();`
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for CLASS_SAVED
}

static void CLASS_SAVED_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MENUS_GROUP_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void CLASS_SAVED_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // CLASS_SAVED behavior
    // uml: do [after_timer1_ms(4000)] TransitionTo(MM_SELECT_CLASS_OPTION)
    if (( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 4000 ))
    {
        // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
        CLASS_SAVED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SELECT_CLASS_OPTION`.
        MAIN_MENU_enter(sm);
        MM_SELECT_CLASS_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for CLASS_SAVED
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MAIN_MENU_exit;
    
    // MAIN_MENU behavior
    // uml: enter / { Display_menu_header("MAIN MENU"); }
    {
        // Step 1: execute action `Display_menu_header("MAIN MENU");`
        Display_menu_header("MAIN MENU");
    } // end of behavior for MAIN_MENU
}

static void MAIN_MENU_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MENUS_GROUP_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_OPTION
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_OPTION_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_OPTION_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_BACK_PRESS_EATER_OPTION_ok_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_BACK_PRESS_EATER_OPTION_up_press;
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: enter / { Display_menu_option("EAT BACK PRESS?"); }
    {
        // Step 1: execute action `Display_menu_option("EAT BACK PRESS?");`
        Display_menu_option("EAT BACK PRESS?");
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: enter / { menu_at_bottom(); }
    {
        // Step 1: execute action `menu_at_bottom();`
        Display_menu_at_bottom();
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
}

static void MM_BACK_PRESS_EATER_OPTION_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MAIN_MENU_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_OPTION_ok_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: OK_PRESS TransitionTo(MM_BACK_PRESS_EATER)
    {
        // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MENUS_GROUP_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER`.
        MM_BACK_PRESS_EATER_enter(sm);
        
        // MM_BACK_PRESS_EATER.InitialState behavior
        // uml: TransitionTo(MM_BACK_PRESS_EATER_1)
        {
            // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_1`.
            MM_BACK_PRESS_EATER_1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_1;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for MM_BACK_PRESS_EATER.InitialState
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
}

static void MM_BACK_PRESS_EATER_OPTION_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // MM_BACK_PRESS_EATER_OPTION behavior
    // uml: UP_PRESS TransitionTo(MM_SHOW_INFO_OPTION)
    {
        // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_OPTION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_OPTION`.
        MM_SHOW_INFO_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_OPTION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SELECT_CLASS_OPTION
////////////////////////////////////////////////////////////////////////////////

static void MM_SELECT_CLASS_OPTION_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SELECT_CLASS_OPTION_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SELECT_CLASS_OPTION_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SELECT_CLASS_OPTION_ok_press;
    
    // MM_SELECT_CLASS_OPTION behavior
    // uml: enter / { Display_menu_option("SELECT CLASS");\nmenu_at_top(); }
    {
        // Step 1: execute action `Display_menu_option("SELECT CLASS");\nmenu_at_top();`
        Display_menu_option("SELECT CLASS");
        Display_menu_at_top();
    } // end of behavior for MM_SELECT_CLASS_OPTION
}

static void MM_SELECT_CLASS_OPTION_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MAIN_MENU_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SELECT_CLASS_OPTION_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SELECT_CLASS_OPTION behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_OPTION)
    {
        // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition).
        MM_SELECT_CLASS_OPTION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_OPTION`.
        MM_SHOW_INFO_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SELECT_CLASS_OPTION
}

static void MM_SELECT_CLASS_OPTION_ok_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // MM_SELECT_CLASS_OPTION behavior
    // uml: OK_PRESS TransitionTo(MM_SELECT_CLASS)
    {
        // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MENUS_GROUP_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SELECT_CLASS`.
        MM_SELECT_CLASS_enter(sm);
        
        // MM_SELECT_CLASS.InitialState behavior
        // uml: TransitionTo(MM_SC_ENGINEER)
        {
            // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MM_SC_ENGINEER`.
            MM_SC_ENGINEER_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for MM_SELECT_CLASS.InitialState
    } // end of behavior for MM_SELECT_CLASS_OPTION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_OPTION
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_OPTION_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SHOW_INFO_OPTION_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_OPTION_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SHOW_INFO_OPTION_ok_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SHOW_INFO_OPTION_up_press;
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: enter / { Display_menu_option("SHOW INFO"); }
    {
        // Step 1: execute action `Display_menu_option("SHOW INFO");`
        Display_menu_option("SHOW INFO");
    } // end of behavior for MM_SHOW_INFO_OPTION
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: enter / { menu_at_mid(); }
    {
        // Step 1: execute action `menu_at_mid();`
        Display_menu_at_mid();
    } // end of behavior for MM_SHOW_INFO_OPTION
}

static void MM_SHOW_INFO_OPTION_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MAIN_MENU_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_OPTION_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: DOWN_PRESS TransitionTo(MM_BACK_PRESS_EATER_OPTION)
    {
        // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_OPTION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_OPTION`.
        MM_BACK_PRESS_EATER_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_OPTION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_OPTION
}

static void MM_SHOW_INFO_OPTION_ok_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: OK_PRESS TransitionTo(MM_SHOW_INFO)
    {
        // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MENUS_GROUP_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO`.
        MM_SHOW_INFO_enter(sm);
        
        // MM_SHOW_INFO.InitialState behavior
        // uml: TransitionTo(MM_SHOW_INFO_1)
        {
            // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MM_SHOW_INFO_1`.
            MM_SHOW_INFO_1_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for MM_SHOW_INFO.InitialState
    } // end of behavior for MM_SHOW_INFO_OPTION
}

static void MM_SHOW_INFO_OPTION_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // MM_SHOW_INFO_OPTION behavior
    // uml: UP_PRESS TransitionTo(MM_SELECT_CLASS_OPTION)
    {
        // Step 1: Exit states until we reach `MAIN_MENU` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_OPTION_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SELECT_CLASS_OPTION`.
        MM_SELECT_CLASS_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_OPTION
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_back_press;
    
    // MM_BACK_PRESS_EATER behavior
    // uml: enter / { back_press_eat_count = 0;\nshow_back_press_count(); }
    {
        // Step 1: execute action `back_press_eat_count = 0;\nshow_back_press_count();`
        sm->vars.back_press_eat_count = 0;
        Display_show_back_press_count(sm->vars.back_press_eat_count);
    } // end of behavior for MM_BACK_PRESS_EATER
}

static void MM_BACK_PRESS_EATER_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MENUS_GROUP_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
}

static void MM_BACK_PRESS_EATER_back_press(LaserTagMenu1Sm* sm)
{
    // Setup handler for next ancestor that listens to `back_press` event.
    sm->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // MM_BACK_PRESS_EATER behavior
    // uml: BACK_PRESS / { back_press_eat_count++;\nshow_back_press_count(); }
    {
        // Step 1: execute action `back_press_eat_count++;\nshow_back_press_count();`
        sm->vars.back_press_eat_count++;
        Display_show_back_press_count(sm->vars.back_press_eat_count);
        
        // Step 2: determine if ancestor gets to handle event next.
        sm->ancestor_event_handler = NULL;  // consume event
    } // end of behavior for MM_BACK_PRESS_EATER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_1
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_1_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_1_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_1_do;
    
    // MM_BACK_PRESS_EATER_1 behavior
    // uml: enter / { show_back_press_taunt("GET TO 5?"); }
    {
        // Step 1: execute action `show_back_press_taunt("GET TO 5?");`
        Display_show_back_press_taunt("GET TO 5?");
    } // end of behavior for MM_BACK_PRESS_EATER_1
}

static void MM_BACK_PRESS_EATER_1_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_1_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_1 behavior
    // uml: do [back_press_eat_count >= 5] TransitionTo(MM_BACK_PRESS_EATER_2)
    if (sm->vars.back_press_eat_count >= 5)
    {
        // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_2`.
        MM_BACK_PRESS_EATER_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_2
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_2_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_2_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_2_do;
    
    // MM_BACK_PRESS_EATER_2 behavior
    // uml: enter / { show_back_press_taunt("BACKPRESS FUTILE"); }
    {
        // Step 1: execute action `show_back_press_taunt("BACKPRESS FUTILE");`
        Display_show_back_press_taunt("BACKPRESS FUTILE");
    } // end of behavior for MM_BACK_PRESS_EATER_2
    
    // MM_BACK_PRESS_EATER_2 behavior
    // uml: enter / { reset_timer1(); }
    {
        // Step 1: execute action `reset_timer1();`
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_2
}

static void MM_BACK_PRESS_EATER_2_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_2_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_2 behavior
    // uml: do [after_timer1_ms(3000)] TransitionTo(MM_BACK_PRESS_EATER_3)
    if (( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 3000 ))
    {
        // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_3`.
        MM_BACK_PRESS_EATER_3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_3
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_3_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_3_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_3_do;
    
    // MM_BACK_PRESS_EATER_3 behavior
    // uml: enter / { show_back_press_taunt("TRY HOLDING BACK"); }
    {
        // Step 1: execute action `show_back_press_taunt("TRY HOLDING BACK");`
        Display_show_back_press_taunt("TRY HOLDING BACK");
    } // end of behavior for MM_BACK_PRESS_EATER_3
    
    // MM_BACK_PRESS_EATER_3 behavior
    // uml: enter / { reset_timer1(); }
    {
        // Step 1: execute action `reset_timer1();`
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_3
}

static void MM_BACK_PRESS_EATER_3_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_3_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_3 behavior
    // uml: do [back_press_eat_count >= 10 && after_timer1_ms(3000)] TransitionTo(MM_BACK_PRESS_EATER_4)
    if (sm->vars.back_press_eat_count >= 10 && ( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 3000 ))
    {
        // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_4`.
        MM_BACK_PRESS_EATER_4_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_4;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_4
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_4_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_4_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_4_do;
    
    // MM_BACK_PRESS_EATER_4 behavior
    // uml: enter / { show_back_press_taunt("I CAN'T EVENT..."); }
    {
        // Step 1: execute action `show_back_press_taunt("I CAN'T EVENT...");`
        Display_show_back_press_taunt("I CAN'T EVENT...");
    } // end of behavior for MM_BACK_PRESS_EATER_4
    
    // MM_BACK_PRESS_EATER_4 behavior
    // uml: enter / { reset_timer1(); }
    {
        // Step 1: execute action `reset_timer1();`
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_4
}

static void MM_BACK_PRESS_EATER_4_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_4_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_4 behavior
    // uml: do [back_press_eat_count >= 15 && after_timer1_ms(3000)] TransitionTo(MM_BACK_PRESS_EATER_5)
    if (sm->vars.back_press_eat_count >= 15 && ( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 3000 ))
    {
        // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_4_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_5`.
        MM_BACK_PRESS_EATER_5_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_4
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_BACK_PRESS_EATER_5
////////////////////////////////////////////////////////////////////////////////

static void MM_BACK_PRESS_EATER_5_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_5_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_5_back_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_5_do;
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: enter / { reset_timer1(); }
    {
        // Step 1: execute action `reset_timer1();`
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_BACK_PRESS_EATER_5
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: enter / { show_random_back_press_taunt(); }
    {
        // Step 1: execute action `show_random_back_press_taunt();`
        Display_show_random_back_press_taunt();
    } // end of behavior for MM_BACK_PRESS_EATER_5
}

static void MM_BACK_PRESS_EATER_5_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_back_press;  // the next ancestor that handles this event is MM_BACK_PRESS_EATER
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_5_back_press(LaserTagMenu1Sm* sm)
{
    // Setup handler for next ancestor that listens to `back_press` event.
    sm->ancestor_event_handler = MM_BACK_PRESS_EATER_back_press;
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: BACK_PRESS / { dont_consume_event(); // allow parent inc count\nreset_timer1();\nshow_random_back_press_taunt(); }
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `dont_consume_event(); // allow parent inc count\nreset_timer1();\nshow_random_back_press_taunt();`
        consume_event = false; // allow parent inc count
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
        Display_show_random_back_press_taunt();
        
        // Step 2: determine if ancestor gets to handle event next.
        if (consume_event)
        {
            sm->ancestor_event_handler = NULL;  // consume event
        }
    } // end of behavior for MM_BACK_PRESS_EATER_5
}

static void MM_BACK_PRESS_EATER_5_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: 1.1. do [after_timer1_ms(2000) && back_press_eat_count > 25] / { back_press_eat_count = 0; } TransitionTo(MM_BACK_PRESS_EATER_2)
    if (( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 2000 ) && sm->vars.back_press_eat_count > 25)
    {
        // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_5_exit(sm);
        
        // Step 2: Transition action: `back_press_eat_count = 0;`.
        sm->vars.back_press_eat_count = 0;
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_2`.
        MM_BACK_PRESS_EATER_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_5
    
    // MM_BACK_PRESS_EATER_5 behavior
    // uml: 2. do [after_timer1_ms(2000)] TransitionTo(MM_BACK_PRESS_EATER_5)
    if (( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 2000 ))
    {
        // Step 1: Exit states until we reach `MM_BACK_PRESS_EATER` state (Least Common Ancestor for transition).
        MM_BACK_PRESS_EATER_5_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_BACK_PRESS_EATER_5`.
        MM_BACK_PRESS_EATER_5_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_BACK_PRESS_EATER_5
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SELECT_CLASS
////////////////////////////////////////////////////////////////////////////////

static void MM_SELECT_CLASS_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SELECT_CLASS_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_SELECT_CLASS_back_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SELECT_CLASS_ok_press;
    
    // MM_SELECT_CLASS behavior
    // uml: enter / { Display_menu_header("SELECT CLASS"); }
    {
        // Step 1: execute action `Display_menu_header("SELECT CLASS");`
        Display_menu_header("SELECT CLASS");
    } // end of behavior for MM_SELECT_CLASS
}

static void MM_SELECT_CLASS_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MENUS_GROUP_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SELECT_CLASS_back_press(LaserTagMenu1Sm* sm)
{
    // Setup handler for next ancestor that listens to `back_press` event.
    sm->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // MM_SELECT_CLASS behavior
    // uml: BACK_PRESS TransitionTo(MM_SELECT_CLASS_OPTION)
    {
        // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MENUS_GROUP_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SELECT_CLASS_OPTION`.
        MAIN_MENU_enter(sm);
        MM_SELECT_CLASS_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for MM_SELECT_CLASS
}

static void MM_SELECT_CLASS_ok_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `ok_press` event.
    
    // MM_SELECT_CLASS behavior
    // uml: OK_PRESS / { save_option_as_class(); } TransitionTo(MM_SELECT_CLASS.ExitPoint(saved))
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MM_SELECT_CLASS_exit);
        
        // Step 2: Transition action: `save_option_as_class();`.
        App_save_player_class(sm->vars.option_value);
        
        // Step 3: Enter/move towards transition target `MM_SELECT_CLASS.ExitPoint(saved)`.
        // MM_SELECT_CLASS.ExitPoint(saved) is a pseudo state and cannot have an `enter` trigger.
        
        // MM_SELECT_CLASS.ExitPoint(saved) behavior
        // uml: TransitionTo(CLASS_SAVED)
        {
            // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
            MM_SELECT_CLASS_exit(sm);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CLASS_SAVED`.
            CLASS_SAVED_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = LaserTagMenu1Sm_StateId_CLASS_SAVED;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for MM_SELECT_CLASS.ExitPoint(saved)
    } // end of behavior for MM_SELECT_CLASS
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_ENGINEER
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_ENGINEER_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SC_ENGINEER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_ENGINEER_down_press;
    
    // MM_SC_ENGINEER behavior
    // uml: enter / { Display_menu_option("ENGINEER");\noption_value = PlayerClass_ENGINEER;\nmenu_at_top(); }
    {
        // Step 1: execute action `Display_menu_option("ENGINEER");\noption_value = PlayerClass_ENGINEER;\nmenu_at_top();`
        Display_menu_option("ENGINEER");
        sm->vars.option_value = PlayerClass_ENGINEER;
        Display_menu_at_top();
    } // end of behavior for MM_SC_ENGINEER
}

static void MM_SC_ENGINEER_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SELECT_CLASS_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_ENGINEER_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SC_ENGINEER behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_HEAVY)
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        MM_SC_ENGINEER_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_HEAVY`.
        MM_SC_MID_enter(sm);
        MM_SC_HEAVY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_HEAVY;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_ENGINEER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_MID
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_MID_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SC_MID_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_HELD] = MM_SC_MID_down_held;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_HELD] = MM_SC_MID_up_held;
    
    // MM_SC_MID behavior
    // uml: enter / { menu_at_mid(); }
    {
        // Step 1: execute action `menu_at_mid();`
        Display_menu_at_mid();
    } // end of behavior for MM_SC_MID
}

static void MM_SC_MID_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SELECT_CLASS_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_HELD] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_HELD] = NULL;  // no ancestor listens to this event
}

static void MM_SC_MID_down_held(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_held` event.
    
    // MM_SC_MID behavior
    // uml: DOWN_HELD TransitionTo(MM_SC_SPY)
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MM_SELECT_CLASS_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_SPY`.
        MM_SC_SPY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_SPY;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_MID
}

static void MM_SC_MID_up_held(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_held` event.
    
    // MM_SC_MID behavior
    // uml: UP_HELD TransitionTo(MM_SC_ENGINEER)
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MM_SELECT_CLASS_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_ENGINEER`.
        MM_SC_ENGINEER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_MID
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_ARCHER
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_ARCHER_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SC_ARCHER_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_ARCHER_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_ARCHER_up_press;
    
    // MM_SC_ARCHER behavior
    // uml: enter / { set_menu_option_and_class(ARCHER); }
    {
        // Step 1: execute action `set_menu_option_and_class(ARCHER);`
        Display_menu_option("ARCHER"); sm->vars.option_value = PlayerClass_ARCHER;
    } // end of behavior for MM_SC_ARCHER
}

static void MM_SC_ARCHER_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SC_MID_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_ARCHER_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SC_ARCHER behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_WIZARD)
    {
        // Step 1: Exit states until we reach `MM_SC_MID` state (Least Common Ancestor for transition).
        MM_SC_ARCHER_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_WIZARD`.
        MM_SC_WIZARD_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_WIZARD;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_ARCHER
}

static void MM_SC_ARCHER_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // MM_SC_ARCHER behavior
    // uml: UP_PRESS TransitionTo(MM_SC_HEAVY)
    {
        // Step 1: Exit states until we reach `MM_SC_MID` state (Least Common Ancestor for transition).
        MM_SC_ARCHER_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_HEAVY`.
        MM_SC_HEAVY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_HEAVY;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_ARCHER
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_HEAVY
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_HEAVY_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SC_HEAVY_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_HEAVY_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_HEAVY_up_press;
    
    // MM_SC_HEAVY behavior
    // uml: enter / { Display_menu_option("HEAVY");\nset_option_class(HEAVY); }
    {
        // Step 1: execute action `Display_menu_option("HEAVY");\nset_option_class(HEAVY);`
        Display_menu_option("HEAVY");
        sm->vars.option_value = PlayerClass_HEAVY;
    } // end of behavior for MM_SC_HEAVY
}

static void MM_SC_HEAVY_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SC_MID_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_HEAVY_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SC_HEAVY behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_ARCHER)
    {
        // Step 1: Exit states until we reach `MM_SC_MID` state (Least Common Ancestor for transition).
        MM_SC_HEAVY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_ARCHER`.
        MM_SC_ARCHER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_ARCHER;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_HEAVY
}

static void MM_SC_HEAVY_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // MM_SC_HEAVY behavior
    // uml: UP_PRESS TransitionTo(MM_SC_ENGINEER)
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MM_SELECT_CLASS_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_ENGINEER`.
        MM_SC_ENGINEER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_HEAVY
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_WIZARD
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_WIZARD_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SC_WIZARD_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_WIZARD_down_press;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_WIZARD_up_press;
    
    // MM_SC_WIZARD behavior
    // uml: enter / { set_menu_option_and_class(WIZARD); }
    {
        // Step 1: execute action `set_menu_option_and_class(WIZARD);`
        Display_menu_option("WIZARD"); sm->vars.option_value = PlayerClass_WIZARD;
    } // end of behavior for MM_SC_WIZARD
}

static void MM_SC_WIZARD_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SC_MID_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_WIZARD_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SC_WIZARD behavior
    // uml: DOWN_PRESS TransitionTo(MM_SC_SPY)
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MM_SELECT_CLASS_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_SPY`.
        MM_SC_SPY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_SPY;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_WIZARD
}

static void MM_SC_WIZARD_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // MM_SC_WIZARD behavior
    // uml: UP_PRESS TransitionTo(MM_SC_ARCHER)
    {
        // Step 1: Exit states until we reach `MM_SC_MID` state (Least Common Ancestor for transition).
        MM_SC_WIZARD_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_ARCHER`.
        MM_SC_ARCHER_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_ARCHER;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_WIZARD
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SC_SPY
////////////////////////////////////////////////////////////////////////////////

static void MM_SC_SPY_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SC_SPY_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_SPY_up_press;
    
    // MM_SC_SPY behavior
    // uml: enter / { set_menu_option_and_class(SPY);\nmenu_at_bottom(); }
    {
        // Step 1: execute action `set_menu_option_and_class(SPY);\nmenu_at_bottom();`
        Display_menu_option("SPY"); sm->vars.option_value = PlayerClass_SPY;
        Display_menu_at_bottom();
    } // end of behavior for MM_SC_SPY
}

static void MM_SC_SPY_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SELECT_CLASS_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_SPY_up_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `up_press` event.
    
    // MM_SC_SPY behavior
    // uml: UP_PRESS TransitionTo(MM_SC_WIZARD)
    {
        // Step 1: Exit states until we reach `MM_SELECT_CLASS` state (Least Common Ancestor for transition).
        MM_SC_SPY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SC_WIZARD`.
        MM_SC_MID_enter(sm);
        MM_SC_WIZARD_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SC_WIZARD;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SC_SPY
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SHOW_INFO_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_SHOW_INFO_back_press;
}

static void MM_SHOW_INFO_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MENUS_GROUP_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
}

static void MM_SHOW_INFO_back_press(LaserTagMenu1Sm* sm)
{
    // Setup handler for next ancestor that listens to `back_press` event.
    sm->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // MM_SHOW_INFO behavior
    // uml: BACK_PRESS TransitionTo(MM_SHOW_INFO_OPTION)
    {
        // Step 1: Exit states until we reach `MENUS_GROUP` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, MENUS_GROUP_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_OPTION`.
        MAIN_MENU_enter(sm);
        MM_SHOW_INFO_OPTION_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for MM_SHOW_INFO
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_1
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_1_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SHOW_INFO_1_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_1_do;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_1_down_press;
    
    // MM_SHOW_INFO_1 behavior
    // uml: enter / { Display_top_line("INFO 1 LINE 1");\nDisplay_bot_line("INFO 1 LINE 2");\nreset_timer1(); }
    {
        // Step 1: execute action `Display_top_line("INFO 1 LINE 1");\nDisplay_bot_line("INFO 1 LINE 2");\nreset_timer1();`
        Display_top_line("INFO 1 LINE 1");
        Display_bot_line("INFO 1 LINE 2");
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_SHOW_INFO_1
}

static void MM_SHOW_INFO_1_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SHOW_INFO_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_1_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_SHOW_INFO_1 behavior
    // uml: do [info_timed_out] TransitionTo(MM_SHOW_INFO_2)
    if ((( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 3000 )))
    {
        // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_2`.
        MM_SHOW_INFO_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_1
}

static void MM_SHOW_INFO_1_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SHOW_INFO_1 behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_2)
    {
        // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_1_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_2`.
        MM_SHOW_INFO_2_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_2
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_2_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SHOW_INFO_2_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_2_do;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_2_down_press;
    
    // MM_SHOW_INFO_2 behavior
    // uml: enter / { Display_top_line("INFO 2 LINE 1");\nDisplay_bot_line("INFO 2 LINE 2");\nreset_timer1(); }
    {
        // Step 1: execute action `Display_top_line("INFO 2 LINE 1");\nDisplay_bot_line("INFO 2 LINE 2");\nreset_timer1();`
        Display_top_line("INFO 2 LINE 1");
        Display_bot_line("INFO 2 LINE 2");
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_SHOW_INFO_2
}

static void MM_SHOW_INFO_2_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SHOW_INFO_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_2_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_SHOW_INFO_2 behavior
    // uml: do [info_timed_out] TransitionTo(MM_SHOW_INFO_3)
    if ((( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 3000 )))
    {
        // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_3`.
        MM_SHOW_INFO_3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_2
}

static void MM_SHOW_INFO_2_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SHOW_INFO_2 behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_3)
    {
        // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_2_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_3`.
        MM_SHOW_INFO_3_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MM_SHOW_INFO_3
////////////////////////////////////////////////////////////////////////////////

static void MM_SHOW_INFO_3_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = MM_SHOW_INFO_3_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_3_do;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_3_down_press;
    
    // MM_SHOW_INFO_3 behavior
    // uml: enter / { Display_top_line("INFO 3 LINE 1");\nDisplay_bot_line("INFO 3 LINE 2");\nreset_timer1(); }
    {
        // Step 1: execute action `Display_top_line("INFO 3 LINE 1");\nDisplay_bot_line("INFO 3 LINE 2");\nreset_timer1();`
        Display_top_line("INFO 3 LINE 1");
        Display_bot_line("INFO 3 LINE 2");
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for MM_SHOW_INFO_3
}

static void MM_SHOW_INFO_3_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = MM_SHOW_INFO_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_3_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // MM_SHOW_INFO_3 behavior
    // uml: do [info_timed_out] TransitionTo(MM_SHOW_INFO_1)
    if ((( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 3000 )))
    {
        // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_1`.
        MM_SHOW_INFO_1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_3
}

static void MM_SHOW_INFO_3_down_press(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `down_press` event.
    
    // MM_SHOW_INFO_3 behavior
    // uml: DOWN_PRESS TransitionTo(MM_SHOW_INFO_1)
    {
        // Step 1: Exit states until we reach `MM_SHOW_INFO` state (Least Common Ancestor for transition).
        MM_SHOW_INFO_3_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MM_SHOW_INFO_1`.
        MM_SHOW_INFO_1_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for MM_SHOW_INFO_3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WELCOME_SCREEN
////////////////////////////////////////////////////////////////////////////////

static void WELCOME_SCREEN_enter(LaserTagMenu1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = WELCOME_SCREEN_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = WELCOME_SCREEN_do;
    
    // WELCOME_SCREEN behavior
    // uml: enter / { Display_top_line("WELCOME!"); }
    {
        // Step 1: execute action `Display_top_line("WELCOME!");`
        Display_top_line("WELCOME!");
    } // end of behavior for WELCOME_SCREEN
    
    // WELCOME_SCREEN behavior
    // uml: enter / { reset_timer1(); }
    {
        // Step 1: execute action `reset_timer1();`
        sm->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior for WELCOME_SCREEN
}

static void WELCOME_SCREEN_exit(LaserTagMenu1Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void WELCOME_SCREEN_do(LaserTagMenu1Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // WELCOME_SCREEN behavior
    // uml: do [after_timer1_ms(2500)] TransitionTo(HOME)
    if (( (PortApi_get_time_ms() - sm->vars.timer1_started_at_ms) >= 2500 ))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WELCOME_SCREEN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        HOME_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for WELCOME_SCREEN
}

// Thread safe.
char const * LaserTagMenu1Sm_state_id_to_string(LaserTagMenu1Sm_StateId id)
{
    switch (id)
    {
        case LaserTagMenu1Sm_StateId_ROOT: return "ROOT";
        case LaserTagMenu1Sm_StateId_HOME: return "HOME";
        case LaserTagMenu1Sm_StateId_HOME1: return "HOME1";
        case LaserTagMenu1Sm_StateId_HOME2: return "HOME2";
        case LaserTagMenu1Sm_StateId_HOME3: return "HOME3";
        case LaserTagMenu1Sm_StateId_MENUS_GROUP: return "MENUS_GROUP";
        case LaserTagMenu1Sm_StateId_CLASS_SAVED: return "CLASS_SAVED";
        case LaserTagMenu1Sm_StateId_MAIN_MENU: return "MAIN_MENU";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_OPTION: return "MM_BACK_PRESS_EATER_OPTION";
        case LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION: return "MM_SELECT_CLASS_OPTION";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION: return "MM_SHOW_INFO_OPTION";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER: return "MM_BACK_PRESS_EATER";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_1: return "MM_BACK_PRESS_EATER_1";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2: return "MM_BACK_PRESS_EATER_2";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_3: return "MM_BACK_PRESS_EATER_3";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_4: return "MM_BACK_PRESS_EATER_4";
        case LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5: return "MM_BACK_PRESS_EATER_5";
        case LaserTagMenu1Sm_StateId_MM_SELECT_CLASS: return "MM_SELECT_CLASS";
        case LaserTagMenu1Sm_StateId_MM_SC_ENGINEER: return "MM_SC_ENGINEER";
        case LaserTagMenu1Sm_StateId_MM_SC_MID: return "MM_SC_MID";
        case LaserTagMenu1Sm_StateId_MM_SC_ARCHER: return "MM_SC_ARCHER";
        case LaserTagMenu1Sm_StateId_MM_SC_HEAVY: return "MM_SC_HEAVY";
        case LaserTagMenu1Sm_StateId_MM_SC_WIZARD: return "MM_SC_WIZARD";
        case LaserTagMenu1Sm_StateId_MM_SC_SPY: return "MM_SC_SPY";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO: return "MM_SHOW_INFO";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1: return "MM_SHOW_INFO_1";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2: return "MM_SHOW_INFO_2";
        case LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3: return "MM_SHOW_INFO_3";
        case LaserTagMenu1Sm_StateId_WELCOME_SCREEN: return "WELCOME_SCREEN";
        default: return "?";
    }
}

// Thread safe.
char const * LaserTagMenu1Sm_event_id_to_string(LaserTagMenu1Sm_EventId id)
{
    switch (id)
    {
        case LaserTagMenu1Sm_EventId_BACK_HELD: return "BACK_HELD";
        case LaserTagMenu1Sm_EventId_BACK_PRESS: return "BACK_PRESS";
        case LaserTagMenu1Sm_EventId_DO: return "DO";
        case LaserTagMenu1Sm_EventId_DOWN_HELD: return "DOWN_HELD";
        case LaserTagMenu1Sm_EventId_DOWN_PRESS: return "DOWN_PRESS";
        case LaserTagMenu1Sm_EventId_OK_PRESS: return "OK_PRESS";
        case LaserTagMenu1Sm_EventId_UP_HELD: return "UP_HELD";
        case LaserTagMenu1Sm_EventId_UP_PRESS: return "UP_PRESS";
        default: return "?";
    }
}
